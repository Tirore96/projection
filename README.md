This repository is the Coq mechanisation that accompanies the paper "Sound and Complete Projection of Multi Party Session Types". The code has been tested with Coq version 8.15.2.

The code is located in the theories/ folder with the following structure

Utils.v : Miscellaneous definitions and proofs\
IndTypes/
  axioms.v, unscoped.v, syntax.v : Generated by autosubst to support substitution\
  elimination.v : Induction principle for global and local types\
CoTypes/
  coGlobal.v : Coinductive Global Types\
  coLocal.v : Coinductive Local Types\
  coProj.v : Coinductive Projection\
Projection/\
  intermediateProj.v : Intermediate Projection\
  projectDecide.v : Decision procedure for intermediate projection\
  indProj.v : Computable Inductive Projection, soundness and completeness proofs

The mapping between the paper to the code is:

Section 2 (Global Types, Local Types, and Standard Projection) -> IndTypes/\
Section 3 (Projection on Coinductive Types) -> CoTypes/\
Section 4 (Projection on Inductive Types: Soundness and Completeness) -> Projection/IndProj.v\
Section 5 (Deciding Projectability) -> Projection/Intermediateproj.v, Projection/ProjectDecide.v

The syntax of inductive global types represented as gType map to the paper presentation the following way
a -> b : k<U>.g ----> GMsg (Action a b k) U g
a -> b : k \{ L0:G0...Ln:Gn \} ----> GBranch (Action a b k) [G0,..,Gn] (where [..] is inductive list)
\mu t.g ----> GRec g (De Brujin indices means the binder is not named)
t ----> GVar n
end ----> GEnd

The representation of (Co)-inductive local type and coinductive global types are similar, with the exception that coinductive branching uses a coinductive list (rather that inductive list as seen above). This is due to a limitation of Coq's productivity checker disallowing a nested fixpoint inside a cofixpoint when defining tocoind. To ensure lists in coinductive types are finite, we define a coercion (to_coseq : seq A -> coseq A) and use the Finite predicate (in CoTypes/coProj.v) to assert all branches gcs is of shape (to_coseq gs).

a -> b :^c k \{ L0:G0^c...Ln:Gn^c \} ----> GCBranch (Action a b k) [G0,..,Gn] (where [..] is inductive list)


Other remarks:

The unraveling relation from Section 3 is represnted by gUnravel (in CoTypes/coGlobal) and lUnravel (in CoTypes/coLocal). The relations gUnravel2 and lUnravel2 are however more convenient (and proved equivalent to their counterparts) so nearly all lemmas (except for the main ones) are stated in terms of these relations.

The graph construction in Section 5 consisting of triple (states,d,delta) is used in CoTypes/coGlobal.v for deciding if a global type unravels to something and Project/projectDecide for deciding intermediate projection. In both cases we represent these graphs' delta and d functions simply as a function computing the list of continations (nextg_unf and nextge_unf respectively).

sat has two implementations (next_rec and pair_next_rec), respectively for deciding unraveling and intermediate projection. For both implementations, their type differ slightly from how sat is presented in the paper by using a predicate P of type A -> seq A -> A, rather than simply being A -> bool. This makes the definition more general, but so far the functiions are only used as has been seen in the paper. 

